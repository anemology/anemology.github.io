[
    
    
    
        
            {
                "id": 0,
                "href": "https://anemology.cc/post/acme-certificate-profile/",
                "title": "ACME Certificate Profile",
                "section": "post",
                "date" : "2025.02.22",
                "body": "最近要將公司服務更新憑證的方式改用 ACME client，在測試的時候發現 pebble 簽發的憑證有效期限從原本的三個月變成了五天，這篇文章會稍微記錄一下原因。\nACME (Automatic Certificate Management Environment) RFC 8555 是為了自動化更新憑證而誕生的一個協定。\npebble 是 Let\u0026rsquo;s Encrypt 提供的 ACME 測試 server，可以簡單地在 CI 環境內或者 local 進行測試，雖然 Let\u0026rsquo;s Encrypt 也有提供 staging 環境，但是有一個 self-hosted 的測試環境再加上可以自訂設定還是比較方便。而這篇文章會用 ACME client certbot 搭配 pebble 測試。\n首先用 docker 起一個 local 的 pebble server，使用 certbot 產生 example.com 憑證，Not Before 會是當下時間，而 Not After 則是三個月後：\n$ openssl x509 -noout -text -in /etc/live/example.com/cert.pem | grep \u0026#34;Validity\u0026#34; -A2 Validity Not Before: Feb 22 08:35:30 2025 GMT Not After : May 23 08:35:29 2025 GMT 再用一次 certbot 加上 --force-renewal 強制 renew 後，發現期限竟然變成了六天後：\n$ openssl x509 -noout -text -in /etc/live/example.com/cert.pem | grep \u0026#34;Validity\u0026#34; -A2 Validity Not Before: Feb 22 09:30:29 2025 GMT Not After : Feb 28 09:30:28 2025 GMT 所以就去查 pebble source code 看有沒有什麼關於有效期限的設定，最後在 test/config/pebble-config.json 內發現 \u0026quot;validityPeriod\u0026quot;: 518400，剛好 518400 秒 == 6 天。\n而 profiles 內有兩個設定，default 和 shortlived， pebble 是怎麼選擇的呢？如果 ACME client 在發出 order 時沒有指定 profile，pebble wfe/wfe.go 就會隨機選\u0026hellip;\nProfile selection 目前還只是 draft，而 Let\u0026rsquo;s Encrypt 在公告內指出會由 server 決定，不確定各 CA 的 ACME server 會怎麼實作\nIf the new-order request does not specify a profile, then the server will select one for it.\n而 certbot 今天剛好在相關的 issue #9261 內有更新，預計今年會實作 ACME profiles。\n如果要固定 profile，暫時的解決方式是修改 pebble-config.json 只留下想要的，或是改用有支援的 client lego。\n最後，有興趣的也可以看看 Let’s Encrypt 最新的公告 We Issued Our First Six Day Cert - Let\u0026rsquo;s Encrypt\n"
            }
    
        ,
            {
                "id": 1,
                "href": "https://anemology.cc/post/find-plurk-permalink/",
                "title": "尋找 Plurk 噗文連結",
                "section": "post",
                "date" : "2022.05.21",
                "body": "最近在改寫自己的 噗浪下載程式，發現噗文連結並沒有在 API response 內，因此尋找了一下，此篇文章則是記錄過程及思路。\n每篇噗文右下角向下箭頭點開，有個開啟網址的連結，可以連到單篇噗文的網頁，網址後段是 /p/xxxxxx。後面的 x 包含英數，看起來像是亂數或是雜湊值產生，初步猜想是後端生成。\n尋找流程 查看 /TimeLine/getPlurks (取得噗文列表)、/Responses/get (取得單篇噗文回應)，這兩支 API 回傳資料都沒有找到對應字串。\n使用瀏覽器 DevTools 的網路，看原始 html 內容，也不是後端 render 回傳，因此判斷是 JavaScript 產生。\n以下截圖皆為 Firefox，使用檢測元素指到 開啟網址 元素，class 是 pif-outlink，JavaScript 通常會使用 css selector + class name 來進行操作。\n切到 DevTools 除錯器，按 Ctrl+Shift+F 搜尋現在網頁所載入的所有資源，在一個 minify 過的 js 內找到這個 class。點左下的大括號來將 js 排版一下，雖然變數命名沒有改變，但至少可以看到比較清楚的排版。\n產生連結的方式是 o.toString(36)，再往上找到 o 的定義，o = r(s)。\n繼續往上，r 的定義是一個 function，.data() 是 jQuery 來取得某元素 data-attribue 的方法，因此可以判斷 e(s) 是某一個元素。\n最後可以得知，一開始的 o 會回傳某一個元素的 data-pid attribute。\n回到 DevTools 檢測器，搜尋 data-pid，發現每一個噗文最外層 div 有這個 attribute，而這個 pid 其實就是 API 回傳的 plurk_id。\n一開始產生連結的方法是 o.toString(36)，查了 MDN 的定義，是產生 n 進位的字串，把值丟進去跑，就可以產生對應的字串了。\n$ Number(1500449470).toString(36) \u0026#34;otbu7y\u0026#34; 最後要轉成 Python code，Python 有內建 hex() 轉換 16 進位文字，但是沒有支援 36 進位，因此使用 mod 和整除的方式來 簡單實作 一下，完成！\n"
            }
    
        ,
            {
                "id": 2,
                "href": "https://anemology.cc/post/hexo-and-next-update/",
                "title": "Hexo 及 NexT 主題升級紀錄",
                "section": "post",
                "date" : "2020.07.19",
                "body": "從去年開始， GitHub 的 dependabot 就會自動偵測 repositories 內 npm 使用的相依套件，如果有安全性問題，bot 就會自動通知並發起 pull request，提醒要更新。\n因我的部落格也很久沒更新了，索性就一次將 Hexo 及 NexT 的主題一起更新到最新版，順便紀錄一下作法方便之後再更新。\nHexo 3.8.0 -\u0026gt; 4.2.1 NexT 5.1.3 -\u0026gt; 7.8.0 大版本更新通常會有 breaking changes，更新後發現有不少問題，因 config 自訂的地方也不多，決定整個打掉重練。\n步驟 建一個全空的 hexo 部落格\n# 更新 hexo-cli npm install hexo-cli -g # 初始化 hexo 至 update_blog 資料夾 hexo init update_blog cd update_blog # 安裝部署使用的套件 hexo-deployer-git npm install hexo-deployer-git 打開 blog 資料夾底下的 package.json，確認 hexo 版本 (\u0026quot;hexo\u0026quot;: \u0026quot;^4.2.1\u0026quot;)\n將原本部落格資料夾內的 scaffolds、source 資料夾複製到 update_blog 內\n將原本部落格資料夾內的 themes/next 資料夾複製到相對應之路徑\n刪除沒有用到的預設主題 themes/landscape\n下載最新的 NexT 主題\ncd update_blog # 因這邊要保留原本舊的 next 主題，所以將新版主題放到不同資料夾 git clone https://github.com/theme-next/hexo-theme-next themes/hexo-theme-next 調整設定檔，這邊都直接使用新版的 yml 檔案\n比對新舊 _config.yml，有 調整過的設定 我用 #@~@ 註記起來，以後比較好找 調整主題設定檔\n比對 themes\\hexo-theme-next\\_config.yml 和 themes\\next\\_config.yml，將有調整過的設定改寫至根目錄底下 _config.yml 的 theme_config: 區塊 好處是主題內的設定檔就維持預設的樣子，以後可以整個資料夾更新，統一在同個設定檔案也比較好維護 另外 NexT 文件 內有提到，也可以將設定寫到 source/_data/next.yml，就看個人選擇 完成之後可以在本機下 hexo server，看一下有無問題\n最後就可以將變更 push 到遠端 hexo 分支，之前設定的 Travis CI 就會自動幫我們部署到 GitHub Pages 啦~\n其他 去掉 post 內的 updated 日期，之後有更新再寫就好，Next 主題修改更新時間的顯示規則 就不用了 不確定這是新版還是舊版 NexT 行為，現在預設是 date 與 updated 不同天，才會顯示更新時間，可以參考 another_day 設定 可以看一下 _config.yml 的 commit 紀錄，會比較清楚 參考網址 Update from NexT v5.1.x\nnpm version 6.9.0 Hexo version 4.2.1 NexT version 7.8.0 git version 2.22.0.windows.1 "
            }
    
        ,
            {
                "id": 3,
                "href": "https://anemology.cc/post/telegram-firstbot-using-nodejs/",
                "title": "第一個 Telegram Bot",
                "section": "post",
                "date" : "2019.07.16",
                "body": "使用 Node.js 打造第一個 Telegram Bot，需要以下東西\nTelegram 帳號 一台可以對外服務的 Server 或 PC 建立 Bot 於 Telegram 內，搜尋 @botfather，BotFather 是 Telegram 官方用來申請以及管理 bot 的機器人，要注意帳號要有藍色小勾勾。 輸入指令 /newbot。 依照指示，依序輸入 bot 的顯示名稱，以及 @username。 最後會得到一組 token，像是 110201543:AAHdqTcvCH1vGWJxfSeofSAs0K5PALDsaw 這樣的字串，用以驗證身份。 setWebhook or getUpdates Telegram Bot 有兩種接收更新的方法，\nsetWebhook - 當 user 輸入指令或是按下按鈕時，Telegram 主動向 Bot post request。 getUpdates - 每隔一段時間，由 Bot 主動向 Telegram 取得資料。 引用 官網的一句話\ngetUpdates is a pull mechanism, setWebhook is push\n選擇用 setWebhook，會比較即時。\n建立自簽憑證 (Self-Signed Certificate) Telegram 要求，使用 Webhook 的 bot 伺服器要有 SSL 憑證，並且可以接受自簽憑證 ( 但憑證的 Common Name 必須是主機的 IP )，所以我們先用自簽憑證。\np.s. 若是有自己的 Domain Name，可以使用 Let\u0026rsquo;s Encrypt 產生正式憑證。\n使用 openssl 建立憑證，輸入指令 openssl req -newkey rsa:2048 -sha256 -nodes -keyout key.pem -x509 -days 365 -out cert.pem。\nCommon Name 必須填入主機的 IP，其餘全部直接按 enter 使用預設值即可。\n撰寫程式 使用 官網 Sample 推薦，已經打包好的 Node-Telegram-bot API，這樣就不用自己去寫 Request 接官方 API。\n先在主機上安裝 Node.js 及 npm ，再照以下安裝 express 及 node-telegram-bot-api。\n# 建立資料夾 mkdir telegram-firstbot # 移動到資料夾內 cd telegram-firstbot # 使用 npm 建立專案 npm init # 建立 index.js touch index.js # 安裝 express npm install --save express # 安裝 Node.js Telegram Bot API npm install --save node-telegram-bot-api index.js 內容如下，記得替換掉以下參數\n@{YOUR_TOKEN} - @botfather 給你的 token @{YOUR_URL_WITHPORT} - 你的 bot 網址，例如 https://1.2.3.4:8443 @{YOUR_PORT} - bot 使用的 port，Telegram 目前只接受 443, 80, 88, 8443 @{YOUR_PRIVATEKEY_PATH\\key.pem} - 於上個步驟產生的 key.pem 檔案路徑 @{YOUR_CERTIFICATE_PATH\\cert.pem} - 於上個步驟產生的 cert.pem 檔案路徑 const TelegramBot = require(\u0026#39;node-telegram-bot-api\u0026#39;); const express = require(\u0026#39;express\u0026#39;); const bodyParser = require(\u0026#39;body-parser\u0026#39;); const fs = require(\u0026#39;fs\u0026#39;); const https = require(\u0026#39;https\u0026#39;); const TOKEN = \u0026#39;@{YOUR_TOKEN}\u0026#39;; const url = \u0026#39;@{YOUR_URL_WITHPORT}\u0026#39;; const port = @{YOUR_PORT}; // certificate const privatekey = fs.readFileSync( \u0026#39;@{YOUR_PRIVATEKEY_PATH\\key.pem}\u0026#39; ); const certificate = fs.readFileSync( \u0026#39;@{YOUR_CERTIFICATE_PATH\\cert.pem}\u0026#39; ); // No need to pass any parameters as we will handle the updates with Express const bot = new TelegramBot(TOKEN); // This informs the Telegram servers of the new webhook. // because we use self-signed certificate, we must provide certificate in parameters. bot.setWebHook(`${url}/bot${TOKEN}`,{ certificate: `@{YOUR_CERTIFICATE_PATH\\cert.pem}`, }); const app = express(); // parse the updates to JSON app.use(bodyParser.json()); // We are receiving updates at the route below! app.post(`/bot${TOKEN}`, (req, res) =\u0026gt; { bot.processUpdate(req.body); res.sendStatus(200); }); app.get(\u0026#39;/\u0026#39;, function (req, res) { res.send(\u0026#39;listening @3@\u0026#39;); }); // Start Express Server with certificates https.createServer({ key: privatekey, cert: certificate }, app).listen(port); // Just to ping! bot.on(\u0026#39;message\u0026#39;, msg =\u0026gt; { bot.sendMessage(msg.chat.id, \u0026#39;You said: \u0026#39; + msg.text); }); 測試 執行 node index.js 輸入網址，https://1.2.3.4:8443 看伺服器是否有回應 listening @3@。 用 Telegram 找到你的 bot，http://t.me/@yourbotusername，測試看看會不會回應我們輸入的訊息。 可以使用 https://api.telegram.org/bot\u0026lt;token\u0026gt;/getWebhookInfo，查看 Webhook 的設定是否正常。 正常的話回應如下\n{ \u0026#34;ok\u0026#34;: true, \u0026#34;result\u0026#34;: { \u0026#34;url\u0026#34;: \u0026#34;https://${ip or domain}:${port}/bot${apikey}\u0026#34;, \u0026#34;has_custom_certificate\u0026#34;: true, \u0026#34;pending_update_count\u0026#34;: 0, \u0026#34;max_connections\u0026#34;: 40 } } 有錯誤可以查看 last_error_messag\n{ \u0026#34;ok\u0026#34;: true, \u0026#34;result\u0026#34;: { \u0026#34;url\u0026#34;: \u0026#34;https://${ip or domain}:${port}/bot${apikey}\u0026#34;, \u0026#34;has_custom_certificate\u0026#34;: true, \u0026#34;pending_update_count\u0026#34;: 2, \u0026#34;last_error_date\u0026#34;: 1560603553, \u0026#34;last_error_message\u0026#34;: \u0026#34;Failed to connect to ${ip or domain}:${port}\u0026#34;, \u0026#34;max_connections\u0026#34;: 40 } } 參考網址 Bots: An introduction for developers - Telegram\nnode-telegram-bot-api/express.js at master · yagop/node-telegram-bot-api\nNode.jsでTelegramのチャットボットを作る\nHow To Create an SSL Certificate on Apache for CentOS 7\nnode.js - How do I setup a SSL certificate for an express.js server? - Stack Overflow\n"
            }
    
        ,
            {
                "id": 4,
                "href": "https://anemology.cc/post/setup-travis-ci-for-hexo-on-github/",
                "title": "使用 Travis CI 自動部署 Hexo 部落格",
                "section": "post",
                "date" : "2019.06.30",
                "body": "之前文章提到，部落格的分支有兩個，hexo 及 master，在 hexo 分支寫文章，之後使用 hexo deploy 部署到 Github 的 master 分支上，確定沒問題的時候再將原始碼 push 到 hexo 分支。\n但本機還需要安裝 nodejs 以及 hexo 才能使用 hexo deploy。\n現在有了 Travis CI 之後，就可以只專注在寫文章上，不用再去思考或是回想 hexo 的指令如何下，流程就會變成以下：\n在本機寫完文章，直接將原始碼 push 到 hexo 分支上，接著 Travis CI 會幫自動做 hexo deploy 的動作，自動部署回 Github。\n連結 Travis CI 直接使用 Github 的帳號登入 Travis CI，將部落格 repo 的開關打開，如下圖， Travis CI 會在我們每一次 push 到 Github 時自動跑建置或測試。\n取得 Github Token 因為部署之後需要 push 回 Github 上，Travis CI 需要額外的 Token，來做這件事，在 Github 上產生一個 Token 供 CI 使用。\nSettings → Developer settings → Personal access tokens → Generate new token → Note 可以註記是 Travis CI 使用 → Select scopes → 只要選 public_repo 就夠了 → Generate token\n然後會出現一段英數字混雜的 token，複製起來貼到 Travis CI Repo 設定的 Environment Variables 的 Value 位置，Name 為 GH_TOKEN，按下 ADD。\n看到很多文章，以前 Travis CI 設定的這些敏感資訊，因為會顯示在 log 裡，需要額外加密。但現在 Travis CI 都直接做好了，像是環境變數等等，在 log 內會變成 [secure] 字串，就不用擔心洩漏的問題。\n編寫 Travis CI 設定檔 Travis CI 的設定檔名稱是 .travis.yml ，是告訴 Travis CI 要做什麼事情，放在網站原始碼的根目錄下就可以。\n# 使用 nodejs language: node_js # 指定 nodejs 版本 node_js: - \u0026#34;10\u0026#34; # 設定需要快取的資料夾，減少往後建置時間 cache: directories: - node_modules # 只在 hexo 分支提交時進行動作 branches: only: - hexo before_install: # 設定時區 - export TZ=\u0026#39;Asia/Taipei\u0026#39; install: # 安裝相關套件 - npm install hexo-cli -g - npm install before_script: # 替換 hexo 設定檔 deploy:repo 的網址，使用 token 進行身分認證及提交，GH_TOKEN 為剛剛設定的 Environment Variables - sed -i\u0026#39;\u0026#39; \u0026#34;s~https://github.com/anemology/anemology.github.io.git~https://${GH_TOKEN}:x-oauth-basic@github.com/anemology/anemology.github.io.git~\u0026#34; _config.yml # 替換 hexo 設定檔 deploy:message 的值，這樣就不用每一次都要去改 deploy 時的訊息，如果用預設的 site update 就可以不用改 - sed -i\u0026#39;\u0026#39; \u0026#34;s~CommitMessageWillReplacedByTravisCI~${TRAVIS_COMMIT_MESSAGE}~\u0026#34; _config.yml script: # 清理 hexo 資料夾 - hexo clean # 建立 public 資料夾 - hexo generate # 因上一篇文章提到的，在不同機器上進行 hexo deploy，紀錄會不見，這邊先將 master repo clone 下來到 .deploy_git 資料夾，就可以保持原先的 commit 紀錄 - git clone --depth 1 -b master https://github.com/anemology/anemology.github.io .deploy_git # 進行部屬 - hexo deploy 總結 這樣之後每一次寫完文章，只要將原始碼 push 到 hexo 分支上，就可以自動部署啦~ 再也不用記 hexo 的指令了。\n或是可以直接在 Github 上對應位置新增 Markdown 檔案，按照 hexo 文章的格式撰寫完，也會有一樣的效果。\n但要注意用 Github 新增檔案的時候，commit 訊息不能填下面的 extended description，在建置的時候 ${TRAVIS_COMMIT_MESSAGE} 那行會出錯，因為 commit 訊息有兩行。 （個人踩雷經驗，或許重新改寫一下 sed 寫法可以解決。\n參考網址 Hexo git deployer removes commits history? Let\u0026rsquo;s do something about that!\nBest Practices in Securing Your Data - Travis CI\n"
            }
    
        ,
            {
                "id": 5,
                "href": "https://anemology.cc/post/hexo-push-to-github-lost-commit-history/",
                "title": "Hexo 部署到 GitHub 之後失去 commit 紀錄",
                "section": "post",
                "date" : "2019.06.23",
                "body": "上禮拜寫完文章之後，用 Hexo deploy 到 Github 之後，發現 commits 全沒了！\n只剩下今天的紀錄，一個 initial commit 和 新增文章的。\n$ git log commit 0c1e76b1e3c34dbc898efcf0be59743a4e715089 (HEAD -\u0026gt; master) Date: Sun Jun 16 14:10:19 2019 +0800 new post - telegram firstbot using nodejs commit dd80cc98ca5539898698b8277f18ba6b6c825e01 Date: Sun Jun 16 14:10:18 2019 +0800 First commit 調查後發現，在本機有一個 .deploy_git 資料夾，是用來 deploy 用的資料夾。\n在 deploy 時的動作是\n檢查有無 .deploy_git 資料夾，如無則建立，並做 initial commit。\n複製 public 資料夾內容到 .deploy_git 資料夾裡。\ncommit 並 push 至 Github 上。\n會發生 commit 紀錄不見的原因有二\n換電腦，本機上沒有 .deploy_git 資料夾，導致 deploy 時重新建立。\ndeploy 時 push 到 Github 上，加了參數 --force。\n最後我去舊電腦裡的資料夾，將 .deploy_git 資料夾弄回來，再重新 deploy 一次就行了。\n若是沒有保留，那些紀錄就真的沒有了。\n所以說要在不同電腦寫作時，還要額外備份 .deploy_git 資料夾，或是在 deploy 前，將 Github 上的紀錄先 pull 到本機上。\n若是沒有換電腦還真的不會踩到這個雷\u0026hellip; git push --force 真的要慎用。\n參考網址 Hexo git deployer removes commits history? Let\u0026rsquo;s do something about that!\nhexojs/hexo-deployer-git: Git deployer plugin for Hexo.\n"
            }
    
        ,
            {
                "id": 6,
                "href": "https://anemology.cc/post/hexo-backup/",
                "title": "Hexo 備份至 GitHub",
                "section": "post",
                "date" : "2018.10.07",
                "body": "如果選擇 GitHub Pages 當部落格的 host，Hexo 雖然會將產生的靜態檔案 deploy 到 GitHub，但我們還是要將原始檔案備份起來，例如寫文章用的 Markdown，或是 Hexo 的設定檔。\n以下就來說說如何在已經建立 username.github.io 儲存庫的情況下，另外開啟一個分支，來儲存我們部落格的原始檔。\n當然也可以在 GitHub 上開一個新的儲存庫，但在參考多方意見後，還是決定在相同的儲存庫下存放檔案。\n首先進入到我們 blog 的資料夾，應該會有以下檔案及資料夾：\nblog/ .deploy_git/ --Hexo deploy to GitHub 用 node_modules/ --npm 套件 public/ --Hexo 產生的靜態檔案 scaffolds/ --Hexo 樣板* source/ --原始文章的 Markdown* themes/ --Hexo 主題* .gitignore --git 排除檔案清單* _config.yml --Hexo 設定檔* db.json --Hexo DB package.json --npm 套件資訊* package-lock.json --npm 套件資訊* 打星號的檔案要放到 GitHub 上，其他檔案因為 npm 或是 Hexo 都會幫我們自動建立，所以不需要特地放到 git 裡。\n其實 Hexo 已經幫我們想好了，在 .gitignore 裡就有排除了不需要放到 git 裡面的檔案，如果你沒有這個檔案，自行新增一個即可。\n.DS_Store Thumbs.db db.json *.log node_modules/ public/ .deploy*/ 加入 git 再來就可以執行 git 指令來將資料夾加入 git：\n#初始化 git init . #建立新分支 hexo git checkout -b hexo #將檔案加入 git git add . git commit -m \u0026#39;Initial commit\u0026#39; #加入遠端儲存庫位址 git remote add origin https://github.com/username/username.github.io.git #將 hexo 分支推送至遠端儲存庫 git push --set-upstream origin hexo 這樣就完成啦，GitHub 的 username.github.io 儲存庫應該就會有兩個分支， master 儲存 Hexo 產生的靜態檔案， hexo 分支儲存我們 blog 的原始檔。\n以後寫完文章之後，就按照普通 git 流程，將檔案 push 至 GitHub 即可。\n還原檔案 如果檔案不小心遺失或想要在另外一台電腦上寫作，也很簡單，步驟如下：\n#將檔案 clone 回來 git clone https://github.com/username/username.github.io.git cd username.github.io/ #切換到 hexo 分支 git checkout hexo #依照 package.json 重新安裝 hexo 套件 npm install #最後啟動 hexo server 看是不是可以正常瀏覽 hexo server 以上。\nnpm version 6.4.1 Hexo version 3.7.1 git version 2.17.0.windows.1 "
            }
    
        ,
            {
                "id": 7,
                "href": "https://anemology.cc/post/sql-server-enabled-sa-account-and-1433-port/",
                "title": "MS SQL Server 啟用 sa 帳戶與 1433 連接埠",
                "section": "post",
                "date" : "2018.06.09",
                "body": "版本: Microsoft SQL Server 2012 R2\n1433 port 開始功能表 -\u0026gt; Microsoft SQL Server 2012 R2 -\u0026gt; 組態工具 -\u0026gt; SQL Server 組態管理員 -\u0026gt; SQL Server 網路組態 -\u0026gt; MSSQLSERVER 的通訊協定 -\u0026gt; TCP/IP -\u0026gt; 已啟用 -\u0026gt; 是 -\u0026gt; IP 位置 -\u0026gt; IPALL -\u0026gt; TCP 通訊埠 -\u0026gt; 1433\n混合驗證模式 伺服器右鍵 -\u0026gt; 屬性 -\u0026gt; 安全性 -\u0026gt; 伺服器驗證 -\u0026gt; SQL Server 及 Windows 驗證模式\nsa 帳戶 伺服器 -\u0026gt; 安全性 -\u0026gt; 登入 -\u0026gt; sa -\u0026gt; 右鍵內容 -\u0026gt; 設定密碼 -\u0026gt; 狀態 -\u0026gt; 設定 -\u0026gt; 登入 -\u0026gt; 已啟用\n所有設定完成之後，記得重啟 SQL Server 服務\n"
            }
    
        ,
            {
                "id": 8,
                "href": "https://anemology.cc/post/how-does-bitcoin-work/",
                "title": "虛擬貨幣 (Bitcoin) 運作原理",
                "section": "post",
                "date" : "2017.12.03",
                "body": "Ever wonder how Bitcoin (and other cryptocurrencies) actually work?\n看完這部影片，可以了解 Bitcoin 背後的原理，以及挖擴到底是在挖什麼?\n以下是個人簡單的筆記 Bitcoin 並沒有一個中心機構來記錄所有的交易行為，而是將所有交易都記錄在一本 公開帳本 中，而 Bitcoin 的本質就是這本帳本。\n所有人都可以在這本帳本上做紀錄，但要如何確保紀錄不會被造假?\n紀錄時會使用 電子簽章 來證明是該人所記錄，而每一筆紀錄都有唯一的序號，就算別人複製了同一筆交易紀錄，但序號不同，驗證的結果也不會通過。\n那誰來維護這本帳本呢?\n帳本會被切割成一個一個區塊，而每個區塊的開頭都會有前一個區塊的 hash 值，以此就可以判斷每個區塊正確的順序，而這也稱為區塊鏈。\n每個區塊除了帳本上記錄的交易行為，還有一個最重要的東西，就是 proof of work，就像每筆紀錄需要電子簽章，每個區塊都需要 proof of work 才能證明它是有效的。\nproof of work 是一個特別的數字，該區塊加上 proof of work 算出來的 hash 值能讓 hash 值前面 n 位數為 0，就代表這個數字就是這個區塊的 proof of work。\n而挖礦就是在計算 proof of work 數字，第一個算出這個數字的人，就可以得到建立這個區塊的獎勵。\n第 5 點講到的 n 是不固定的，Bitcoin 會隨時改變 n，以確保每 10 分鐘都可以有一個區塊產生。\nSHA-256 破解 Bitcoin 的 hash 值是用 SHA-256 雜湊演算法來運算，而 SHA-256 有多難破解，可以看看以下這個影片\nHow secure is 256 bit security?\n"
            }
    
        ,
            {
                "id": 9,
                "href": "https://anemology.cc/post/hexo-introduction-and-commands/",
                "title": "Hexo 介紹和常用指令",
                "section": "post",
                "date" : "2017.11.25",
                "body": "Hexo 是什麼? Hexo 是一個基於 Node.js 所建立的網誌框架，你不需要懂 Node.js，只要會下 command 就行了。 使用 Markdown 來編寫文章，Hexo 會將你寫的 Markdown 文章解析並產生靜態檔案，可以直接部署到 GitHub 上，完全不需要後端的支援。\n大多數人部署到 GitHub 的原因是，它可以免費置放靜態檔案，缺點是必須公開所有的程式碼， 而 Hexo 也有方便的指令可以將你的網誌部署到 GitHub 上。 當然其他網頁伺服器軟體也可以，但就要自行架設主機，建置環境。\n我選擇 Hexo 的原因是\u0026hellip;它有完整的繁體中文文件! 你也可以選擇很多人在用的 Jekyll、Hugo\nHexo 常用指令 hexo server\r啟動伺服器，瀏覽 http://localhost:4000/ 就可以看到所產生好的網誌。\nhexo new post HelloWorld\r建立一篇新的文章，在 source\\_posts 底下會產生一個 HelloWorld.md 的檔案，編輯這個檔案來撰寫文章。\nhexo clean\r刪除快取檔案 db.json 和放置靜態檔案的 public 資料夾。\nhexo generate\r產生靜態檔案於 public 資料夾。\nhexo deploy\r部屬網誌，需先於 _config.yml 中設定 deploy 相關參數。\n"
            }
    
        ,
            {
                "id": 10,
                "href": "https://anemology.cc/post/next-edit-time/",
                "title": "Next 主題修改更新時間的顯示規則",
                "section": "post",
                "date" : "2017.11.25",
                "body": "只有在更新時間 \u0026gt; 發表時間的時候才顯示\n修改 themes\\next\\layout\\_macro\u0026lt;span style=\u0026ldquo;color:red\u0026rdquo;\u0026gt;post.swig 兩個 if 判斷子句中加入 and post.updated \u0026gt; post.date\n\u0026lt;div class=\u0026#34;post-meta\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;post-time\u0026#34;\u0026gt; {% if theme.post_meta.created_at and theme.post_meta.updated_at and post.updated \u0026gt; post.date %} \u0026lt;span class=\u0026#34;post-meta-divider\u0026#34;\u0026gt;|\u0026lt;/span\u0026gt; {% endif %} {% if theme.post_meta.updated_at and post.updated \u0026gt; post.date %} \u0026lt;span class=\u0026#34;post-meta-item-icon\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa fa-calendar-check-o\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;/span\u0026gt; {% if theme.post_meta.item_text %} \u0026lt;span class=\u0026#34;post-meta-item-text\u0026#34;\u0026gt;{{ __(\u0026#39;post.modified\u0026#39;) }}\u0026amp;#58;\u0026lt;/span\u0026gt; {% endif %} \u0026lt;time title=\u0026#34;{{ __(\u0026#39;post.modified\u0026#39;) }}\u0026#34; itemprop=\u0026#34;dateModified\u0026#34; datetime=\u0026#34;{{ moment(post.updated).format() }}\u0026#34;\u0026gt; {{ date(post.updated, config.date_format) }} \u0026lt;/time\u0026gt; {% endif %} \u0026lt;/span\u0026gt; "
            }
    
        ,
            {
                "id": 11,
                "href": "https://anemology.cc/post/ssh-key-login-linux/",
                "title": "使用 SSH Key 登入 Linux Server",
                "section": "post",
                "date" : "2017.01.07",
                "body": "最近因為在玩 P2P 的東西，所以需要一台 24/7 的電腦來跑。\n剛好 GitHub Education 之前有送 DigitalOcean $50，就先拿來用了。\n怎麼在 DigitalOcean 建立 Droplet 就不說了，新建立好像可以直接匯入 SSH Key，就不用手動加 SSH Key。\nOS: Ubuntu 16.04.1 x64\nroot 連到 Linux Server，建立一個新的使用者。\nadd user whatever 將使用者加入 sudo 群組。\ngpasswd -a whatever sudo 使用 PuTTYgen 建立公私鑰，也可以在 Linux 上用 ssh-keygen 指令建立。\n登入剛剛建立的新使用者，在家目錄建立 .ssh 目錄。\nsu - whatever mkdir .ssh chmod 700 .ssh 新增 authorized_keys 檔案，並將公鑰內容貼進去，Ctrl+X 存檔。\nnano .ssh/authorized_keys chmod 600 .ssh/authorized_keys 輸入 exit 切換回 root，修改這個檔案。\nnano /etc/ssh/sshd_config 拿掉這幾行前面的註解 #。\nRSAAuthentication yes PubkeyAuthentication yes AuthorizedKeysFile %h/.ssh/authorized_keys 將 PasswordAuthentication 設置為 no，就不能用密碼登入嚕。\nPasswordAuthentication no Ctrl+X 存檔後，重啟服務。\nservice ssh restart 接著就可以在 PuTTY，用剛剛存下來的私鑰做驗證登入了 (不用密碼)。\n因為公鑰是存放在 whatever 的家目錄，所以只能用 whatever 登入。\n要用 root 登入的話就要在 /root 做同樣的事情，或是調整 sshd_config 的設定，不建議啦。\n參考資料：\nInitial Server Setup with Ubuntu 14.04\n"
            }
    
        ,
            {
                "id": 12,
                "href": "https://anemology.cc/post/anagrams/",
                "title": "Anagrams",
                "section": "post",
                "date" : "2016.06.29",
                "body": "面試時做線上測試遇到一個 Anagrams 的問題，所以在這裡筆記一下~\n原始題目網址：https://www.testdome.com/Questions/PHP/AreAnagrams/4838?visibility=1\u0026amp;skillId=5\n判斷兩個字串是否為 Anagrams (暫譯:變位詞) Anagrams 的意思是兩個字串的組成是否相同\napple 和 pplea 會輸出 true\nbird 和 biidd 則會輸出 false\n解決方法\n判斷兩個字串長度是否相同，若不同就可以直接輸出 false。 將字串分割成陣列。 將陣列依照字母順序排列。 比對陣列裡的每個元素是否相同。 參考網址: [HackerRank]Java變位詞(Java Anagrams) | MagicLen\n"
            }
    
        ,
            {
                "id": 13,
                "href": "https://anemology.cc/about/",
                "title": "About",
                "section": "",
                "date" : "2016.06.19",
                "body": "What is WordPress.com?\nWhat can WordPress.com do?\nHow can I use WordPress.com?\nLet me tell you!\nAh\u0026hellip; I use Hexo now! :P @@\nSorry it\u0026rsquo;s Hugo :)\nIf you have any question, please go to GitHub and create an issue.\nMilestone 2016/06/19 Open blog on WordPress.com. 2017/11/19 Move blog to GitHub Pages + Hexo. 2018/10/06 Add custom domain anemology.cc 2022/05/21 Change static site generator to Hugo. "
            }
    
]
